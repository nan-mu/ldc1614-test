# 参数计算方式

> 记录了从原理图中信息得到完成代码关于ldc1614的一切注意事项和参数记录方式

## 参数注册函数

### `Fsensor`

#### `from_inductance_capacitance`

```rust
impl Fsensor {
    pub const fn from_inductance_capacitance(
        inductance: f32,
        capacitance: f32
    ) -> Self
}
```

设置传感器频率，$f_{SENSORx}$

根据以 $\mu H$ 为单位的电感和以 $pF$ 为单位的电容计算传感器的工作频率，实际上是线圈中LC振荡器的谐振频率。

TODO: 用工作频率这个词合适吗？

理论上，这里的电感是指线圈的电感，理论上会印在线圈板上。电容的值理论上是验证板上端口并联的电容.

电容的值为330 $pF$,外部晶振的值由验证板原理图知道是40MHz。

TODO:电感的值是多少


TODO: 补充线圈板和验证板相关资料的下载链接

TODO: 补充在验证版上具体是哪个电容


#### `to_clock_dividers`

```rust
impl Fsensor {
    pub const fn to_clock_dividers(
        &self,
        ext_clk_freq: Option<f32>
    ) -> ClockDividers
}
```

根据 $f_{SENSORx}$ 和 $f_{REFx}$ （晶振频率，单位为 MHz）计算最小时钟分频器。

如果使用内部晶振，就传递 `None`，默认为 $43 MHz$。但我们使用外部晶振的话就填写原理图中晶振的频率，单位为 $MHz$。

根据得到的震荡器频率加以分频系数得到一个能直接输出到时钟分频相关寄存器的对象，也就是`ClockDividers`。

### `Ldc`

#### `set_clock_dividers`

```rust
impl Ldc{
    pub fn set_clock_dividers(
        &mut self,
        ch: Channel,
        divs: ClockDividers
    ) -> Result<(), Error<BE>>
}
```

在代码中是向 `0x14 + (通道对应偏移)` 写入一个`ClockDividers`，在实例中`ClockDividers`通过`Fsensor::to_clock_dividers`获得。在文档中对应寄存器`CLOCK_DIVIDERSx`。该寄存器设置通道输入分频（Channel Input Divider）和通道参考频率分频。两者分别是为了设置通道输入频率 $f_{inx}$ 和通道参考频率$f_{REFx}$。具体的设置公式如下（x为输入到寄存器中的值）：

$$
f_{inx}(x)=\frac{f_{SENSORx}}{x}\\
f_{REF0}(x)=\frac{f_{CLK}}{x}
$$

其中[文档](https://www.ti.com/lit/ds/symlink/ldc1614.pdf#page=24)还提到：

> 如果 $f_{SENSORx}$ 大于等于 $8.75MHz$，则必须将通道输入分频设置大于等于 $2$。
>
> 设置通道参考频率用以调整最大转换频率。

在[文档](https://www.ti.com/lit/ds/symlink/ldc1614.pdf#page=51)中寄存器设置为`0x1002`。对应将通道输入分频设置为 $1$，通道参考频率分频设置为 $2$。在库`ldc1x1x`中按照以下代码设置：

```rust
fin_div= (self.0 / 8.75 + 1.0) as u16;
fref_div= if self.0 * 4.0 < fref {
        1
    } else if self.0 / 2.0 * 4.0 < fref {
        2
    } else {
        4
};
```

推荐使用库函数设置，不直接操作寄存器。

TODO: 要不要补充一下为什么？

#### `set_conv_settling_time`

```rust
impl Ldc{
    pub fn set_conv_settling_time(
        &mut self,
        ch: Channel,
        cnt: u16
    ) -> Result<(), Error<BE>>
}
```

设置稳定时间，$Settle Time$，$t_{s0}$。

在代码中是向 `0x10 + (通道对应偏移)` 写入一个`u16`。在文档中对应寄存器`SETTLECOUNTx`。规格书中关于此寄存器的描述为：

> LDC 将利用这个稳定时间让 LC 传感器在启动通道 x 的转换之前稳定下来。
>
> 如果在转换开始前振幅尚未稳定，并且启用了此类错误的报告功能，则会产生振幅错误。

其中，设置为`0x0`或`0x1`表示设置稳定时间为$\frac{32}{f_{REF0}}$。设置为其他数字则计算公式为：$Settle Time(t_{S0}) = \frac{x\times16}{f_{REF0}}$。

在[文档](https://www.ti.com/lit/ds/symlink/ldc1614.pdf#page=51)中，推荐设置为`0x000A`，在库`ldc1x1x`中推荐设置为`40`。

> 我建议搭建完自动化测试框架的时候编写代码测试1到256的结果有何变化。

TODO: 等到测试完成后将结论贴在此处。

####  `set_ref_count_conv_interval`
```rust
impl Ldc{
    pub fn set_ref_count_conv_interval(
        &mut self,
        ch: Channel,
        intv: u16
    ) -> Result<(), Error<BE>>
}
```
设置参考计数的转换间隔，$ConversionTime$，$t_{c0}$。

在代码中是向 `ox08 + (通道对应偏移)` 写入一个 `u16`。在文档中对应寄存器 `RCOUNTx`。规格书中关于此寄存器的描述为：

>LDC1614 转换提供了测量分辨率和转换间隔之间的权衡。
>
>较长的转换间隔具有更高的测量分辨率。转换间隔可配置为 3.2 μs 至 >26.2 ms，分辨率为 16 位。
>
>请注意，可以将 conversion interval 配置为短于读回 DATAx registers所需的时间。LDC1612/LDC1614 支持通过设置 RCOUNTx 寄存器来调整每个通道的转换间隔。

任何通道x的转换时间计算公式为：$Conversion Time(t_{cx}) = \frac{RCOUNTx\times16+4}{f_{REFx}}$.

不过一般来说，较长的转换时间将提供更高分辨率的电感测量。全分辨率需要最大设置 0xFFFF。而在[文档](https://www.ti.com/lit/ds/symlink/ldc1614.pdf#page=51)中，推荐设置为0x04D6.

#### `set_sensor_drive_current`
```rust
impl Ldc{

    pub fn set_sensor_drive_current(
        &mut self,
        ch: Channel,
        cur: u8
    ) -> Result<(), Error<BE>>
}
```
用于控制传感器驱动电流，使传感器信号幅度在 1.2 V 至 1.8 V 的最佳范围内。

代码配置的是DRIVE_CURRENTx寄存器，将 `u8` 类型的 `cur` 写入`ox1E + (通道对应偏移)` ，cur的取值参考[文档](https://www.ti.com/lit/ds/symlink/ldc1614.pdf#page=42)的表42配置。

按照[文档](https://www.ti.com/lit/ds/symlink/ldc1614.pdf#page=11)所说，有两种方式可以设置驱动电流值。
##### 配置驱动电流的方法1 
其中一种就是调用上述方法配置DRIVE_CURRENTx寄存器，在这种方式下，必须禁用自动幅度校正且 RP over ride=1。

了解$I_{DRIVE}$的计算方法：$I_{DRIVE} = \frac{pi\times(V_{P})}{4R_{P}}$

TODO:这个公式里的pi咋打？

其中$R_{P}$是与传感器相连的电阻值，如果测得的 $R_{P}$（在传感器和目标之间的最大间距处）的值介于[文档](https://www.ti.com/lit/ds/symlink/ldc1614.pdf#page=42)的表42两个表值之间，也就是说电流驱动值可以有多个取值，就使用与较低的$R_{P}$相关联的电流驱动值。

##### 配置驱动电流的方法2
另一种驱动电流设置方式，LDC可以自动确定合适的传感器电流驱动，甚至可以通过使用 RP_OVERRIDE_EN 功能动态调整传感器电流。常用于初次调试，不过对于高精度测量和大多数应用，非常不建议采用这种方式，应该用固定电流。

`由于$R_{P}$值可能面临难以确定的情况，所以考虑用 RP_OVERRIDE_EN 自动设置 IDRIVE。`

LDC可以在进入活动模式时自动确定适当的传感器电流驱动。如果传感器振幅未知，自动传感器振幅设置对于初始系统原型设计非常有用。启用此功能后，LDC 会尝试查找 IDRIVEx 设置，该设置导致传感器幅度在 1.2 V 和 1.8V 之间。

注意：对于目标交互变化较大的系统，LDC可以选择在目标交互范围内可重复性较差的电流驱动设置。此外，使用不同的传感器电流驱动时，测量可重复性会更差。要启用自动传感器振幅，要将 RP_OVERRIDE 设置为 b0。

##### 以下序列使用自动校准来配置具有未知 $R_{P}$ 的传感器的传感器驱动电流：

1、将目标设置为距传感器的最大计划工作距离。

TODO:其实我有一些不太理解目标和传感器的摆放方式，这就导致我不太理解所谓的`Rp（在传感器和目标之间的最大间距处）的值`以及`将目标设置为距传感器的最大计划工作距离`

2、通过设置 CONFIG 将设备置于 SLEEP 模式。SLEEP_MODE_EN 到 b0。
```rust
// 创建默认配置
let config = Config(0);

// 设置新的配置, with_active_chan只选择了通道0
let new_config = config
    .with_active_chan(Channel::Zero)
    .with_sleep_mode(true);

// 应用配置到 LDC 设备
ldc.set_config(new_config).unwrap();
```

3、为通道编写所需的 SETTLECOUNT 和 RCOUNT 值
```rust
let ch=ldc::Channel::Zero;
ldc.set_conv_settling_time(ch, 40).unwrap();
ldc.set_ref_count_conv_interval(ch, 0x0546).unwrap();
```

4、通过将 RP_OVERRIDE_EN 设置为 b0 来启用自动校准。
```rust
// 设置新的配置, with_active_chan只选择了通道0
let new_config = config
    .with_active_chan(Channel::Zero)
    .with_sleep_mode(true)
    .with_automatic_sensor_amplitude_correction(false);
```

5、通过设置 CONFIG 使设备退出 SLEEP 模式。SLEEP_MODE_EN 到 b1。

6、允许设备至少执行一次测量，目标稳定（固定）在最大工作范围内。

7、从相应的DRIVE_CURRENTx寄存器（地址 0x1e、0x1f、0x20 或 0x21）的 INIT_DRIVEx 字段（位 10：6）中读取通道电流驱动值。保存此值。

8、在正常操作模式启动期间，将从 INIT_DRIVEx 位字段保存的值写入 IDRIVEx 位字段（位 15：11）。

9、在正常工作模式下，固定电流驱动的 RP_OVERRIDE_EN 应设置为 b1。


### `MuxConfig`
























